## 一、概述

在这个简短的教程中，我们将探讨为 Spring 应用程序提取请求标头的各种方法。我们将学习如何针对特定端点执行此操作，之后，我们将创建一个*HandlerInterceptor* 来拦截所有传入请求并提取标头。

## 2. 使用*HttpServletRequest*

**为了能够访问有关 HTTP 请求的信息，我们可以声明一个\*HttpServletRequest\*对象作为我们端点的参数。**这允许我们查看详细信息，例如路径、查询参数、cookie 和标头。

例如，我们可以使用*HttpServletRequest*在收到请求时提取自定义标头。要访问某个标头，我们可以通过指定标头的键来使用*getHeader()方法：*

```java
@RestController
public class FooBarController {

    @GetMapping("foo")
    public String foo(HttpServletRequest request) {
        String operator = request.getHeader("operator");
        return "hello, " + operator;
    }

}复制
```

我们可以使用[MockMvc](https://www.baeldung.com/integration-testing-in-spring)发送包含自定义标头的*GET请求。*如果我们将运算符标头设置为*“John.Doe”*，我们将期望响应为*“hello, John.Doe”*：

```java
@Test
public void givenARequestWithOperatorHeader_whenWeCallFooEndpoint_thenOperatorIsExtracted() throws Exception {
    MockHttpServletResponse response = this.mockMvc.perform(get("/foo").header("operator", "John.Doe"))
      .andDo(print())
      .andReturn()
      .getResponse();

    assertThat(response.getContentAsString()).isEqualTo("hello, John.Doe");
}复制
```

但是，如果我们只需要请求中的一个特定标头，则将整个*HttpServletRequest*声明为参数可能会被视为违反[接口隔离原则](https://www.baeldung.com/java-interface-segregation)，即 SOLID 中的“I”。

## 3.使用*@RequestHeader*

访问特定端点的请求标头的另一种简单方法是使用*@RequestHeader*注释：

```java
@GetMapping("bar")
public String bar(@RequestHeader("operator") String operator) {
    return "hello, " + operator;
}复制
```

**因此，我们的代码不再与整个\*HttpServletRequest\*对象耦合，我们的方法现在使用所有传入的数据作为参数。**

让我们为此端点编写一个类似的测试并期望得到相同的结果：

```java
@Test
public void givenARequestWithOperatorHeader_whenWeCallBarEndpoint_thenOperatorIsExtracted() throws Exception {
    MockHttpServletResponse response = this.mockMvc.perform(get("/bar").header("operator", "John.Doe"))
      .andDo(print())
      .andReturn()
      .getResponse();

    assertThat(response.getContentAsString()).isEqualTo("hello, John.Doe");
}复制
```

## 4.使用*HandlerInterceptor*

**对于更复杂的用例，我们可以使用\*HandlerInterceptor\*对象。优点是它可以拦截所有传入的请求并提取标头的值。**

此外，我们可以将标头的值包装在具有*请求*范围的 Spring bean 中，并将其注入到可能需要的不同组件中。

首先，让我们将运算符名称包装到一个对象中：

```java
public class OperatorHolder {
    private String operator;
    // getter and setter
}复制
```

*现在，让我们使用@Bean*将其声明为一个 bean 。运算符可能因一个请求而异，因此我们应该将 bean 范围设置为*SCOPE_REQUEST*：

```java
@Bean
@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
public OperatorHolder operatorHolder() {
    return new OperatorHolder();
}复制
```

之后，我们需要创建*HandlerInterceptor*接口的自定义实现，并覆盖*preHandle()*方法*：*

```java
public class OperatorInterceptor implements HandlerInterceptor {
    private final OperatorHolder operatorHolder;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String operator = request.getHeader("operator");
        operatorHolder.setOperator(operator);
        return true;
    }
    // constructor
}复制
```

结果，请求被拦截，运算符标头被提取，*OperatorHolder* bean 被更新。

最后，我们需要将自定义拦截器添加到 Spring MVC 的*InterceptorRegistry*中。我们可以通过实现*WebMvcConfigurer* 并覆盖*addInterceptor()*的配置类来实现：

```java
@Configuration
public class HeaderInterceptorConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(final InterceptorRegistry registry) {
        registry.addInterceptor(operatorInterceptor());
    }

    @Bean
    public OperatorInterceptor operatorInterceptor() {
        return new OperatorInterceptor(operatorHolder());
    }
}复制
```

现在要访问操作符，我们只需要注入 *OperatorHolder* bean 并调用*getOperator()*方法：

```java
@RestController
public class BuzzController {
    private final OperatorHolder operatorHolder;

    @GetMapping("buzz")
    public String buzz() {
        return "hello, " + operatorHolder.getOperator();
    }
    // constructor
}复制
```

## 5.结论

在本文中，我们探讨了访问传入 HTTP 请求的自定义标头的各种方法。

*最初，我们通过HttpServletRequest*和*@RequestHeader*学习了如何针对特定端点执行此操作。之后，我们看到了*HandlerInterceptor*如何允许我们从所有传入请求中提取标头并提供更通用的解决方案。